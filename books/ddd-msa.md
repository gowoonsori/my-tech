# 도메인 주도 설계로 시작하는 마이크로서비스 개발

## 마이크로서비스를 위한 조건
1. 업무 기능 중심의 팀
   - 기술별로 팀이 나눠지게 되면 서비스 한개를 개발하는데 많은 의사소통이 필요하고 의사결정이 느려진다. 업무기능을 중심으로 다양한 기술을 가진 사람들이 하나의 팀이 되어 서비스를 만들어야 한다.

1. 폴리글랏 프로그래밍
   - 각각의 서비스에 맞는 효율적인 방법론과 도구, 기술을 찾아 적용.

1. 개발 생명주기는 프로젝트단위가 아닌 제품 중심
   - 초기에 모든 일정을 계획하고 요구사항 정의, 설계, 개발을 진행하는 것은 변경이나 새로운 아이디어를 포용하기 힘들다. 제품중심의 애자일 개방 방식을 채용하여 단기간의 스프린트로 계속한 개발/피드백으로 제품을 지속적으로 변화, 개선하는 것이 마이크로서비스이다.

1. 통합 저장소가 아닌 데이터를 나눠 관리
   - 과거에는 스토리지 가격 및 네트워크 속도에 따라 통합저장소를 많이 이용했지만 현재는 가격도 저렴하고 네트워크 대역폭이 매우 커졌다.
   - 폴리그랏 저장소 접근법 : 서비스별로 db를 갖도록 설계 ( 각 저장소가 서비스별로 분산 ) 

        다른 서비스의 저장소를 직접 호출할 수 없고 API를 통해서만 접근해야 한다는 의미

        - 문제점 : 데이터의 비즈니스 정합성를 맞춰야하는 데이터 일관성 문제
        - 해결방법 
          - 비동기 이벤트 처리를 통한 협업 (결과적 일관성) : 두 서비스의 데이터가 일시적으로 불일치하는 시점이 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념

            여러 트랜잭션을 하나로 묶지 않고 별도의 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념

            아래와 같이 `메시지 큐`를 이용

            ![보상 트랜잭션](/books/image/transaction.PNG)

1. 실패를 고려한 설계
    - 테스트 환경 갖추기
    - 모니터링 체계 갖추기
    - 서킷 브레이커 패턴 : 각 서비스를 모니터링 하다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응하는 것

        `넷플릭스`는 `카오스 몽키`라는 일부러 장애를 발생시키는 도구를 만들어 탄력적인 아키텍처가 제대로 동작하는지 점검한다.

<br><br>

## 2. MSA의 이해
### 리액티브 시스템의 4가지 특성
- 응답성 : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공
- 탄력성 : 장애가 발생하거나 부분적으로 고장나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력
- 유연성 : 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것 ( 시스템 사용량에 비래하여 자원을 늘리거나 줄이는 능력)
- 메시지 기반 : 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향

### 운영과 관리를 위한 플랫폼 패턴
#### 서비스 디스커버리(서비스 레지스트리) 패턴
![서비스 디스커버리](/books/image/serviceDiscovery.PNG)
클라이언트가 여러개의 마이크로서비스를 호출하기 위해서 최적 경로를 찾아주는 라우팅(ex. Zuul), 부하분산을 위한 로드밸런싱(Ribbon) 기능이 필요하다. 이때 라우터는 최적의 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP를 알아야 하는데 유동 IP의 정보를 매핑해서 보관할 저장소(Eureka)도 필요하는데 이러한 패턴을 서비스 레지스트리 패턴이라고 한다.

Netflix OSS 뿐만이 아닌 쿠버네티스 DNS 및 서비스로도 제공하는 기능으로 다른 솔루션들도 존재

#### API 게이트웨이 패턴
![게이트웨이](/books/image/gateway.PNG)
다양한 클라이언트가 다양한 서비스에 접근하기 위해 단일 진입점을 만들어 두는 패턴으로 L4와 같이 하드웨어로 구현할 수도 있고 소프트웨어로 구현할 수도 있다. API 게이트웨이는 아래와 같은 기능을 제공한다.

- 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
- 권한 서비스와 연계한 인증/인가
- 로그 집계 서비스와 연계한 로깅
- 메트릭
- 트레이싱 서비스와 연계한 서비스 추적
- 모니터링 서비스와 연계한 장애 격리

대표적인 솔루션으로 Spring API Gateway Service나 k8s service와 ingress resources가 있다.

#### BFF 패턴 (Backend for Frontend)
![BFF](/books/image/BFF.PNG)

다양한 종류의 클라이언트를 위해 특화된 처리를 위한 패턴으로 프런트엔드의 유형에 따라 각각 진입점을 두는 패턴.

처리를 수행하는 BFF를 두고 이후에 통합적인 API 게이트웨이를 둠으로써 공통적인 인증/인가, 로깅 등을 처리하는 방식으로 구성

#### 외부 구성 저장소 패턴
`Config`원칙 : 애플리케이션이 배포되는 환경(스테이징, 프로덕션, 개발, 테스트)이 매번 달라지기 때문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다는 원칙.

한마디로 클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안된다는 원칙

#### 인증/인가 패턴
- 중앙 집중식 세션 관리 : 서비스들은 언제든 스케일아웃할 수 있으므로 각자의 서비스에 저장하는 것이 아니라 공유저장소에 세션을 저장
- 클라이언트 토큰 : 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장되어 사용자의 신원 정보를 포함하고 있기 때문에 서버에서 인가 처리를 할 수 있다.
- API 게이트웨이를 사용한 클라이언트 토큰 : Auth service로 별도로 인증/인가를 처리하는 전담 서비스를 두어 인증/인가의 처리를 위임할 수 있다. Auth serivce를 이용하면 각 리소스 서비스가 자체적으로 인증/인가를 처리하지 않고 자신의 역할에 집중할 수 있도록 해준다.

#### 서킷 브레이커 패턴
하나의 서비스에 장애가 발생했을때 다른 서비스가 영향을 받을 수 있는데 이때 장애가 발생한 서비스를 격리하여 유연하게 처리할 수 있도록 해주는 패턴

서비스A가 서비스B를 호출하여 서비스를 할때 서비스B에서 장애가 발생하면 동기 요청 특성상 A까지도 장애가 발생한 것 처럼 느끼게 되는데 연속 실패 횟수가 임계값을 초과하면 fallback 메서드를 통해 대체응답을 보내는 방법

#### 모니터링과 추적
서비스 모니터링(Hystrix Dashboard), 분산 트레이싱 서비스(Zipkin) 등 다양한 솔루션을 활용하여 모니터링과 장애, 지연구간을 추적하여 개선할 수 있도록 해준다.

#### 로그 집계 패턴
로그는 시작과 끝이 고정된 것이 아니라 서비스가 실행되는 동안 계속 흐르는 흐름으로 이벤트 스트림으로 처리해야 한다.

#### 서비스 메시 패턴
문제 해결을 위한 기능(서비스 탐색, 서킷 브레이크, 추적, 로드 밸런싱) 등을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 패턴

`사이드카 패턴` : 모는 서비스 컨테이너에 추가로 `사이드카 컨테이너`가 배포되는 패턴으로 각 서비스를 연계할 때 한 서비스가 다른 서비스를 직접 호출하지 않고 사이드카인 프록시를 통해 연계해서 개발자가 별도의 작업 없이 관리 및 운영에 대한 서비스 등을 적용

### 애플리케이션 패턴
#### UI 컴포지드 패턴 ( 마이크로 프런트엔드 패턴 )
프론트엔드도 기능별로 분리하고 프레임 형태의 창을 통해 여러 프레임을 조합하여 동작하게 한다. 이 부모 서비스는 틀만 가지고 있고 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 하고 이 각각의 프론트엔드들은 여러개의 백엔드 마이크로 서비스API를 호출한다.

#### 통신 패턴
- 동기 통신 : 일반적인 REST API같은 방법.

    호출받은 마이크로서비스에 장애가 발생하면 호출한 서비스는 반응이 올 때까지 기다리게 되어 장애가 연쇄적으로 발생할 우려가 있다.

- 비동기 통신 : 메시지 큐를 통해 event driven 방식으로 구현
  
    kafka,rabbitMQ, ActiveMQ 등의 메시지 브로커를 이용하거나, AWS의 SQS/SNS, Azure의 EventHub/EventGrid 등의 완전관리형 클라우드 벤더를 이용해 구현할 수 있다.

#### 저장소 분리 패턴
각 서비스는 각자의 비즈니스를 처리하기 위해 데이터를 직접 소유한다는 것. 자신의 데이터를 다른 서비스에 직접 노출하지 않고 API를 통해서만 노출하기 때문에 정보은닉/폴리그랏 저장소를 만족하고 데이터를 토한 변경의 파급효과를 줄일 수 있다.

#### 분산 트랜잭션 처리 패턴
전통적인 방법은 2단계 커밋을 통해 구현할 수 있지만 이 방법은 각 서비스에 잠금이 걸려 발생하는 성능 문제 탓에 효율적인 방법이 아니며 MongoDB같은 NoSQL은 2단계 커밋을 지원하지 않는다.

- Saga 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴으로 분산된 여러 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상트랜잭션을 통해 데이터의 정합성을 맞춘다.
  
  >보상 트랜잭션? 어떤 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션


>결과적 일관성? 모든 비즈니스 규칙들이 실시간으로 일관성을 맞출 필요가 없다. 예를 들어, 결제 주문이 완료된후 메일을 보내는 시스템인데 주문이 몰리는 블랙프라이데이라고 가정을 해보자. 수만개의 주문이 발생하는데 결제 서비스에서 타사 외부 연동 장애가 발생해 더는 주문을 받을 수 없는 상황이 발생할 수 있는데 비즈니스 관점에서 보면 이를 모두 순차적으로 처리하기보다 주문을 먼저 많이 받아놓는 것이 더 좋을 수도 있다. 그 후 결제 서비스가 복구되었을때 처리하여 결과적으로는 일관성을 만족하게 되는 것이 더 좋을 수 있다.
>
>이 처럼 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 되었을때 일관성을 만족해도 되는 것.

#### CQRS 패턴
Command Query Responsibility Segregation의 약자로 명령 조회 책임 분리를 의미.

하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리하거나, 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비하여 쓰기 시스템의 부하를 줄이고 조회 대기 시간을 줄이는 방법.

#### 이벤트 소싱패턴
저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야 하는데 이 과정에서 객체의 상태변화를 메시지로 발행하고 객체 상태를 관계형 db에 저장하는 경우 SQL질의어로 변환해서 처리하기가 매우 번거롭고 까다로우며 성능이 빠르지 않은데 이를 해결할 수 있는 패턴

비즈니스로직을 모두 수행후 최종 결과값을 저장하는 방식이 아닌 상태 트랜잭션 자체를 저장하는 전략으로 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장하는 방법. 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용해 쓰기 속도가 훨씬 빠르다.

만일 현재 시점의 상태가 필요하다면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산하면 되며, 이것이 부담된다면 매일 자정에 상태를 계산한 후 스냅샷으로 저장하여 이 스냅샷 이후의 트랜잭션만 처리하면 된다. 이렇게 되면 특정 시점의 상태를 재현할 수 있기 때문에 로그 데이터를 기록할 필요도 없다.

이렇게 되면 삭제/수정없이 입력/조회만 일어나기 때문에 명령 서비스를 확장해도 동시 업데이트/교착 상태가 발생하지 않는다.

<br><Br>

## 3. 애플리케이션 아키텍처
### 레이어드 아키텍처
- 프레젠테이션 : 화면 표현 및 전환 처리 
- 비즈니스 로직 : 비즈니스 개념 및 규칙, 흐름제어
- 데이터 액세스 : 데이터 처리
  
#### 규칙 
1. 상위 계층이 하위 계층을 호출하는 단방향성 유지
2. 상위 계층은 하위의 여러 계층을 모두 알 필요없이 바로 밑 계층만 활용
3. 상위 계층이 하위 계층에 영향을 받지 않게 구성
4. 하위 계층은 상위 계층을 알지 못하게 구성
5. 계층간의 호출은 인터페이스를 통해 호출하도록 구성 

#### 구현 방식
규칙 5에 의해 각 계층의 인터페이스를 통해 호출하도록 구성했다고 해보자. 데이터 액세스 계층의 인터페이스를 이용하여 비즈니스 로직을 처리한다고 할때 DIP는 만족한 것 처럼 보인다. 하지만 OCP에 문제가 발생한다. 각 계층이 자기 자신의 인터페이스를 정의하고 소유하고 있는 구조로 하위 계층의 유형이 추가되어 확장되어 인터페이스가 바뀌게 되면 이를 사용하는 닫혀있어야 할 상위 계층에도 영향이 가기 때문이다.

저수준이 가지고 있는 인터페이스를 고수준 계층으로 옮김으로써 DIP와 OCP를 해결할 수 있다.

### 헥사고날 아키텍처
![헥사고날](/books/image/hexagonal.png)
현대 애플리케이션은 위처럼 단순하게 3가지의 계층만 존재하는 것이 아니라 더 다양한 인터페이스,시스템 유형, 저장소 들이 존재하기 때문에 한계가 존재한다.

`앨리스테어 콕번`이 제시한 아키텍처로 `포트 & 어댑터 아키텍처`라고도 한다.

고수준의 비즈니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부영역으로 분리하는 아키텍처. 그리고 외부 영역과 연계되는 포트를 가지고 있다. 

포트
- 인바운드 포트 : 내부 영역의 사용을 위해 호출된 api로 외부영역의 인바운드 어댑터가 호출한다.
- 아웃바운드 포트 : 내부 영역이 외부를 호출하는 방법을 정의

어댑터
- 인바운드 어댑터 : 외부에서 들어오는 요청을 처리하는 어댑터로 외부영역이 소유. <br>컨트롤러, 커맨드 핸들러, 이벤트 메시지 구독 핸들러 등이 될 수 있다.
- 아웃바운드 어댑터 : 비즈니스 로직에 의해 호출되어 외부와 연계. <br>DAO, 이벤트 발행 클래스, 외부 서비스 호출하는 프록시 등이 될 수 있다.

### 클린 아키텍처
로버트 C.마틴은 `소프트웨어는 행위 가치보다 구조 가치가 더 중요하다`라고 말했는데 구조가치가 소프트웨어를 더 부드럽게 만들기 때문이라고 한다.

- 엔티티 : 가장 중앙에 위치한 부분으로 비즈니스 업무 규칙이 정의 되어 있는 부분
- 유스케이스 : 어플리케이션 업무 규칙으로 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다. 
- 세부사항 : 위 두개을 제외한 모든 영역으로 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜들이 될 수 있다. 이때 세부사항과 유스케이스의 관계를 의존 관계 역전의 원칙을 이용해 플러그인처럼 유연하게 처리해야 한다.
