
# 그래프
```
연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조
```
### :heavy_check_mark: 개념
------
- 정점(vertex) / 노드(node) : 위치
- 간선(edge) / 링크(link) : 위치간의 관계
- 인접 정점 : 간선에 의해 직접 연결된 노드
- 차수 : 하나의 노드에 인접한 노드의 수
- 경로 길이 : 경로를 구성하는 데 사용된 간선의 수
- 단순 경로 : 경로 중에서 반복되는 간선이 없을 경우
- 사이클 : 단순경로의 시작 정점과 종료 정점이 동일한 경로
- 연결 그래프 : 무방향 그래프에 있는 모든 노드쌍에 대해 항상 경로가 존재한 경우
- 완전 그래프 : 모든 노드가 서로 연결되어 있는 그래프
- 오일러 경로 : 모든 간선을 한 번만 통과하면서 처음 정점으로 돌아오는 경로
- 오일러 정리 : 간선이 짝수일 때만 오일러 경로가 존재

<br><br>

### :heavy_check_mark: 표현 방법
------
- 인접 행렬(2차원 배열)
```
밀집 그래프 : 간선이 많이 존재하는 그래프
희소 그래프 : 간선이 적은 그래프

배열은 노드를 n개를 갖는다고 한다면 n^2만큼 메모리가 필요하기에 희소 그래프는 메모리 낭비가 될 수 있다.
따라서 밀집 그래프가 적합하다.
```

- 인접 리스트 ( 연결 리스트 )
```
노드의 개수가 n개이고 노드의 개수가 e개인 무방향 그래프를 그리는데 있어 n개의 연결 리스트, n개의 헤드 포인터, 2e개의 노드가
필요하다.
간선의 개수가 적은 희소 그래프가 적합하다.
```

<br><br>

### :heavy_check_mark: 탐색

<br>

- 깊이 우선 탐색( DFS )
-------
시작 노드에서 출발하여 먼저 다음 노드로 향하면서 탐색한 곳은 표시를 해두고 더이상 갈 수 있는 노드가 없다면 이전 노드에서 다른 노드로 향하여 모든 노드를 탐색하는 방식.
```
    유사 코드

    노드를 방문했다고 표시
    해당 노드 출력
    for 연결되어 있는 모든 노드 확인
        if 방문 하지 않고 연결되어 있는 노드
            재귀 함수
```

노드의 수가 n, 간선의 수가 e 인 그래프의 DFS 탐색 시간은 인접 리스트 O(n+e) / 인접 행렬 O(n^2)
--> 희소 그래프인 경우 dfs에서는 인접 리스트 사용이 시간적으로 더 유리하다.

<br><br>

- 너비 우선 탐색( BFS )
------
시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
큐를 이용하여 노드를 삽입하고 방문한 노드는 큐에서 빼내는 방식으로 구현
```
    유사 코드

    노드를 방문했다고 표시
    queue에 노드번호 삽입
    while 큐가 비어있을때까지
        queue pop
        pop값 출력
        for 노드에 연결되어있는 모든 노드 탐색
            if 방문하지 않은 노드라면
                큐에 삽입
                노드 방문표시
```
노드의 수 n, 간선의 수 e인 그래프 BFS탐색 시간은 인접 리스트 O(n+e) / 인접 행열 O(n^2)
--> 희소그래프의 경우 인접 리스트를 사용하는 것이 유리하다.

<br><br>

### :heavy_check_mark: 신장 트리
```
Spanning Tree
- 그래프 내의 모든 정점을 포함하는 트리
- 모든 정점들이 연결되어 있어야 하고 사이클은 포함되지 않는 형태
- n개의 노드를 정확이 n-1개의 간선으로 연결된다.
- 하나의 그래프에는 많은 신장 트리 존재 가능
```
- 구현
```
    유사 코드

    노드 방문 표시
    for 인접한 노드 탐색
        if 방문하지 않은 노드
            간선 표시
            재귀함수
```

<br>

### :heavy_check_mark: 최소 비용 신장 트리
```
Minimum Spanning Tree
- 신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리
- 모든 정점들이 연결되어 있어야 하고 사이클은 포함되지 않는 형태
- n개의 노드를 정확이 n-1개의 간선으로 연결된다.
```
#### 구현

- Krustkal MST
```
탐욕적인 방법( Greedy Method )

- 간선 선택 기반 알고리즘
- 간선 선택 단계에서 사이클을 포함하지 않고 최소 비용 간선을 선택
```

```
[과정]

    1. 그래프의 가중치를 이용하여 오름차순 정렬
    2. 정렬된 리스트에서 사이클 포함하지 않은 간선 선택
    3. 선택한 간선을 MST 집합에 추가
```
<br><br>

- Prim MST
```
- 정점 선택 기반
- 시작 정점부터 출발하여 신장 트리 집합을 단계적으로 확장
```

```
[과정]

    1. 시작 정점 MST에 추가
    2. 앞 단계의 MST에 인접한 정점들 중 최소 간선 정점 선택
    3. MST가 n-1개 간선을 가질때 까지 반복
```