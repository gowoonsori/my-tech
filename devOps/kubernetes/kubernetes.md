# 가상화 기술의 역사

1. 자원격리기술 Linux의 자원을 분리하여 독립적으로 사용가능하게 하는 기술로 출발 (chroot, namespace, cgroup 등..)

2. VM 가상화 기술등장으로 자원을 분리가 가능했고, rackspace와 나사에서 open Stack이 등장하여 이걸 이용해 자동화를 시도 -> 자동화는 되는데 시스템 효율이 나지 않는다.

   vm가상화를 하기 위해서 무거운 os를 띄워야하고, 가벼운 서비스를 띄우기 위해 더 큰 서비스를 띄워야하는 경우도 생겨 자원이 효율적이지 않다.

3. 컨테이너 가상화 기술 (dotCloud -> docker)

   서비스간에 자원격리를 하는데 os를 별도로 안띄워도 되기 대문에 os 기동시간이 없기 때문에 자동화시 엄청 빠르고, 자원효율도 좋다.

   Docker 자체는 하나의 서비스를 컨테이너로 가상화 시켜 배포하는 것. (엄청 많은 서비스를 일일이 배포하고 운영해주는 역할x)

4. 컨테이너 오케스트레이터 (kubernates, docker swarm, ECS, Rancher Cattle,,Hashicorp Nomad ...)

   많은 서비스를 배포하고 운영하는 역할 (여러 컨테이너들을 관리해주는 기술)

# 가상화 기술의 장점

대규모의 서비스를 운영할때, 최대한 자원을 효율적으로 사용해야 비용적으로 유리하기 때문에 서버 자원을 효율적으로 사용하기 위해 가상화 기술 사용

# 컨테이너 와 VM

docker와 같은 컨테이너 가상화 기술은 Host os위에 자원격리기술이용해 컨테이너 단위로 서비스를 분리하여 개발환경에 상관없이 동작 가능하게 해준다.

아래와 같이 자원 격리 기술을 이용해 서비스를 컨테이너 단위로 구성

- namespace (mnt/pid/net/ipc/uts/user) : 커널에 관련된 영역 분리
- cgroups (memory,cpu, I/O, network) 자원에 관련된 영역 분리

VM은 Host os 위에 Hypervisor기술을 이용해 Guest OS를 구성하는 방법

VM은 하나의 VM이 보안이 뚫려도 다른 OS와는 독립적인 공간이라 안전하나 container는 한 컨테이너가 뚫리면 Host OS가 위험하다.

# 쿠버네티스

위의 역사에서 봤듯이 쿠버네티스는 컨테이너화된 애플리케이션을 자동화 관리 시스템으로 `오픈 소스 기반`이다.

구글에 의해 프로젝트가 시작되었으며, 각종 기업들이 참여해 프로젝트를 진행하였고 현재는 `리눅스 재단`이 관리

여러 컨테이너들을 `Pod`라는 개념을 이용해 컨테이너들을 묶고 분류할 수 있다.

## Kubernetes 객체 내부

![k8s Object](/devOps/kubernetes/image/k8sObject.PNG)
서버 한대는 `Master`(쿠버네티스의 전반적인 역할)로 사용하고 `node`들은 자원을 제공하는 역할로, 이들이 묶어 `Cluster`라는 개념으로 사용하고 Cluster안에 각각의 Namespace가 존재하여 쿠버네티스 Object들을 독립된 공간으로 분리되게 만들어 준다.

한 `Pod`가 배포의 단위이고 이 Pod들을 외부와 연결하기 위해 ip와 포트등 관리하기위한 `Service`가 존재하고 Pod가 문제가 생겨 재생성이 될때 데이터가 날라가는 문제를 해결하기 위해 `volume`을 생성해 저장장치에 저장하여 데이터를 관리
이 들은 `Namespace`안에서 동작

Namespace안에 `ResourceQuota / LimitRange`를 통해 namespace안에서 사용할 수 있는 자원의 양을 조절 가능하고(pod의 개수, cpu,memory등 ) `ConfigMap/Secret`으로 Pod생성시 컨테이너 안에 환경변수 값을 넣어두는 등 세팅을 할 수있게 해준다.

또, 각각의 Pod를 관리하는 `Controller`가 존재

- Replication Controller, ReplicaSet : Pod가 죽으면 감지해 살리거나 Pod를 Scaling 해주는 controller

- Deployment : Pode의 Upgrade를 담당하는 controller
- DaemonSet : 한 노드에 한 Pod만 유지되도록 하는 역할
- CronJob : 어떤 특정 작업만 하고 종료를 시켜야하는 일을 할 수 있도록 해준다.

<br>

- 클러스터 : k8s가 시스템을 구성하는 다양한 업무를 실행하는데 사용하는 다수의 컴퓨터, 스토리지, 네트워크 리소스의 집합
- 노드 : 단일 호스트로 물리 머신이거나 가상머신, pod를 실행시키고 이 노드들은 마스터에 의해 관리 된다. 한마디로 일벌
- 마스터 : api 서버, 스케줄러, 컨트롤러 매니저등 여러 컴포넌트로 구성되어 포드 스케줄링과 이벤트 처리를 담당
- 포드 : k8s의 작업 단위로 포드에는 한개/여러개의 컨테이너가 존재한다.
- 라벨 : 키/값쌍의 객체 집합으로 포드를 그룹화할때 사용하고 한 파드에 여러개의 라벨을 붙일수 있다.
- 어노테이션 : 임의의 메타데이터를 k8s 객체와 연결할 수 있어 메타데이터를 사용할 수 있게 한다.
- 라벨 셀렉터 : 라벨을 기반으로 객체를 선택하며, `동등 기반 셀렉터`와 `집합 기반 셀렉터`가 존재한다.
- 복제 컨트롤러/복제 세트 : 라벨 셀렉터로 식별된 포드 그룹을 관리하고 특정 수 만큼 항상 실행 중인지 확인한다. 복제 컨트롤러는 동일 여부로, 복제 세트는 집합 기반으로 구성원을 확인한다.
   롤링 업데이트나 일회성 작업 실행과 같은 많은 업무 흐름의 중심에 있다.
- 서비스 : 사용자나 다른 서비스에 특정 기능을 노출하는데 사용되고 특정 라벨을 가지고 있는 포드를 선택해 묶을 수 있다. OSI7계층6에서 3계층에서 동작한다.
- 볼륨 : 데이터가 포드보다 오래 보존되거나 포드간에 데이터를 공유해야 하는 경우에 사용될 수 있으며 계속해서 확장되어가는 중이다.
- 스테이트풀세트 : 복제 컨트롤러와 유사하게 지정된 시간에 지정된 수만큼의 서버을 실행하거나 제거, 찾을 수 있도록 보장한다.
- 시크릿 : 자격증명과 토큰 같이 민감한 정보를 가진 작은 객체로 etcd에 저장되어 k8s api서버를 통해 접근이 가능하다.
- 이름 : k8s의 객체들은 각각 UID와 이름으로 식별되고 api 호출 시 객체를 참조할 때 사용된다.
- 네임 스페이스 : 가상 클러스터로 이 각각의 가상 클러스터는 다른 클러스터와 완전히 분리되어 있으며 공용 인터페이스를 통해서만 통신할 수 있다.
## 기능

---

### Auto Scaling

자동 확장으로, 특정 서비스(서버)에 트래픽이 몰리면 여유있고 쉬고 있는 서버를 자동으로 확장하여 사용하는 방법 - 트래픽이 적은 시간에는 일부 서버를 절전모드로 전환하여 전기 비용을 절약 가능 - 총 사용량으로 요금을 부과하기 때문에, 요금을 낮출 수 있다. - 트래픽에 민감하게 대응이 가능하다.

### Auto Healing

자동 복구로, 특정 서버가(인스턴스) 죽게되면 자동으로 새로운 인스턴스에 볼륨을 연결하여 기능을 수행하게 하는 방법

### Deployment

무중단 배포를 위해 자동적으로 update를 지원

<br><br>

## 분산 시스템 디자인 패턴
### 사이드카 패턴
포드에 있는 다른 컨테이너를 메인 애플리케이션 컨테이너에 함께 배치하는 패턴으로 애플리케이션 컨테이너는 사이드카 컨테이너가 추가된 것을 인지 하지 못하고 일을 수행한다.
중앙 집중식 로깅 에이전트가 예로 사이드카 컨테이너가 모든 로그를 중앙으로 전송하고 집계하는데 이러한 중앙 집중식 로그 수집 환경으로 발생하는 부담을 해소 할 수 있고 로깅 정책을 갱신하거나 변경할 경우 사이드카 컨테이너만 업데이트/배포를 진행하면 되므로 애플리케이션이 중단될 일이 없다.

### 앰버서더 패턴
원격 서비스가 마치 로컬인 것처럼 운영되도록 일부 정책을 시행하는 것으로 쓰기 작업용 마스터와 읽기작업용 다수로 구성된 레디스 클러스터가 예이다.

로컬 레디스 환겨에서 테스트할 경우 많은 도움이 되며 레디스 클러스터 구성의 변경이 있는 경우 앰버서더만 수정하면 되고 애플리케이션은 영향을 받지 않게 된다.

### 다중 노드 패턴
단일 노드 패턴은 포드를 통해 k8s가 직접 지원하지만 리더 선출, 작업 큐, 분산 수집 같은 다중 노드 패턴은 k8s가 직접적으로 지원하지 않고 표준 인터페이스를 사용해서 포드를 구성한 k8s에서 실행 가능한 접근 방식이다.

<br><br><br>

---
### Reference
[인프런-김태민님 강의](https://www.inflearn.com/course/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B8%B0%EC%B4%88/dashboard)

[k8s 공식홈페이지](https://kubernetes.io/docs/reference)