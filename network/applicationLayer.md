# 응용 계층 ( Application Layer )

---

네트워크 애플리케이션은 컴퓨터 네트워크의 존재 이유.

호스트와 직접 상호작용하며 개발자는 종단 시스템에서 어떻게 조직되어야 하는지를 설계.

<br><br>

## 용어 개념

---

- **프로세스** : 호스트에서 실행되고 있는 프로그램

- **소켓** : 프로세스와 프로세스간 통신을 위한 문 역할을 하며 이 소켓을 통해 통신을 한다.
  <br>애플리케이션과 네트워크 사이의 API (Application Programming Interface)라고도 한다.
- **포트 (port)** : 네트워크 서비스나 프로세스들을 구분하기 위한 번호.
  <br>16비트 (65536)로 이루어져있다.
  |포트 번호| 할당되었는지 유무 |
  |:---:|:---:|
  |0 ~ 1023 | 잘 알려진 포트 |
  |1024 ~ 49,151 | 등록된 포트 |
  |49,152 ~ 65535 | 동적 포트 |

    <br>

  ![tcp/ip port](/network/image/port.PNG)

  위 사진은 tcp/ip 프로토콜 스택의 잘알려진 프로토콜들의 포트 번호이다.

### 애플리케이션 구조

- 클라이언트-서버 구조 : 항상 켜져있는 호스트인 `서버`에게 `클라이언트`라는 다른 많은 호스트 들이 요청을 하고 응답을 하는 구조.

- P2P (Peer to Perr) 구조 : 항상 운영되는 호스트는 없을 수도 있으며, 간헐적으로 연결된 호스트 쌍인 `피어`들이 서로 직접 통신한다.
  <br>`자가 확장성`이 있어 한쪽은 응답, 요청만 수행하는 것이 아닌 두 기능을 모두 수행하여 작업 부하를 분배한다.

<br><br>

## HTTP 프로토콜

---

웹 서비스를 위한 응용계층의 프로토콜이다.

웹 브라우저를 통해 HTTP 클라이언트 부분을 구현 하고 호스트는 이 브라우저를 통해 데이터를 요청하면 서버는 응답을 대기하다가 요청하는 데이터를 응답하는 방식.

<br>

### ✔ 특징

- 전송계층의 `TCP` 프로토콜 이용

- `비상태 프로토콜`로 클라이언트에 대한 정보를 유지하지 않는다.
- `비연결 지향` 프로토콜이다.
- `온 디맨드` 방식으로 요청이 있어야 응답을 하는 방식 ( pull 방식 )
- 각 객체는 메세지 속에 `캡술화` 하여 전송.

<br>

### ✔ 연결 방법

- **비지속 연결**

HTTP는 기본적으로 `비상태 프로토콜`로 `비지속 연결`이 기본이다. 이 때문에, 브라우저 내에 수많은 데이터를 요청할때마다 연결을 시도후 파일요청을 하고 종료를 반복하게 된다.
<br>때문에 파일 요청시마다 연결/종료를 반복해 한개의 파일에 `2RTT`만큼의 시간이 걸린다.

<br>

- **지속 연결**

어떠한 기법으로 인해 연결상태가 지속이 된다면, 종료가 끝날때까지 연결을 반복하지 않으니 데이터의 수가 많을수록 `1RTT`의 수준으로 응답 지연 속도가 떨어 지게 된다.

<br><br>

### ✔ HTTP 지속 연결 방법

---

- 쿠키 : 사용자 추적 및 관리를 위해 사용되며 사용자의 기록 정보 파일이다.

  클라이언트와 서버간의 쿠키정보를 공유하여 동일한 사용자의 복수 트랜잭션을 구분하여 처리하기 위함이다.

  위와 같은 이유 때문에 개인정보에 위험이 된다.

  저장형식이 text이며 용량 제한이 있다.

  응답 / 요청 메세지 쿠키 헤더라인에 포함되며, 사용자 브라우저에 저장된다.

- 세션 : 일종의 웹 서버에 저장되는 쿠키로 사용자가 일정 시간 내에 요청하는 요구를 하나의 상태로 보고, 일정하게 유지시키는 기술
  <br>저장형식이 객체이며 용량제한은 서버가 허용되는 만큼이다.
- 웹 캐시 : proxy 서버라고도 하며 클라이언트와 서버사이에서 복사본을 가지고 서버대신에 요청을 처리하는 기법이다.
  병목링크로 인한 전송율 감소를 막아 요청의 응답시간 감소와 링크 트래픽 감소가 목적이다.
  - 조건부 GET : 프록시 서버가 가지고있는 사본이 최신이 아닐 수 있는 문제점을 해결하기 위해 나온 방법으로,클라이언트의 HTTP 요청이 `IF-Modified-Since` 헤더라인과 `GET`방식이라면 프락시 서버는 서버로부터 최신 파일인지 묻고 요청하는 방법.

<br>

### ✔ HTTP 요청 방법

아래 두 함수 모두 요청(request)를 위한 방법이지만, 방법의 차이가 존재한다.

- `GET` : 요청하는 파라미터를 HTTP헤더의 요청라인에 포함하여 전송한다.

  때문에 길이의 제한이 있으며, url로 노출이 되기 때문에 post방식보다는 보안위험에 노출이 된다.

  따라서, 비밀번호와 같은 중요한 정보가 아닌 데이터를 얻기위한 쿼리문으로 이용이 바람직하다.

- `POST` : 요청하는 파라미터를 HTTP헤더의 body에 포함하여 전송하는 방식.

<br><br>

## 전자메일 (SMTP)

---

인터넷 전자메일을 서비스하기 위한 프로토콜이다.

호스트의 클라이언트를 `사용자 에이전트 (User Agent)`라 하며, 메일을 보내고 저장하는 일을 하는 `메일 서버`가 존재한다.

<br>

### ✔ 특징

- 전송계층의 `TCP`프로토콜을 이용
- Http와는 다르게 `push`방식으로 작동한다. ( 상대방 서버에 밀어 넣는 방식 )
- 각 메세지가 7비트 ASCII로 인코딩 되어야 한다.
- 모든 메세지의 객체를 한 메세지로 만든다.

<br>

### ✔ 전송 방법

호스트가 클라이언트를(UA) 이용하여 메일을 보내면 UA에서 메일서버로 메일을 보내고 호스트의 메일 서버는 상대방의 메일 서버에 메일을 밀어 넣게되며, 전달 할 수 없다면 호스트의 메일 서버에 `메세지 큐`에 보관하고 일정 시간뒤에 재전송을 시도한다.

<br>

### ✔ 수신 방법 ( 메일 접속 프로토콜 )

상대방이 밀어넣은 메일을 내 메일서버에서 UA로 가져오게 될때는 pull 방식의 프로토콜이 필요하게 된다.
이때 등장하는 프로토콜은 `POP3` 와 `IMAP`방식이 있다.

- **POP3** : `110번 port`를 이용하며, 간단한 메일 접속 프로토콜로 기능이 한정적이다.

  POP3서버는 POP3세션 사이의 상태 정보를 전달하지 않기 때문에, 메일서버에서 UA로 메세지를 가져오게 되면 (읽게 되면) 서버에서 메일은 삭제한다.

- **IMAP** : POP3보다 더 다양한 특성을 갖지만 복잡하다.
  POP3와 달리 메일을 읽어도 서버에서 삭제가 되지 않고 유지 시킨다.

<br>

### ✔ 웹 기반 전자메일

호스트는 자기의 메일 서버(메일 박스)에 있는 메일을 보고자 할때, POP3이나 IMAP을 이용하지 않고 HTTP를 통해 메일을 가져오게 된다.

또한 UA에서 자신의 메일 서버로 메일을 보낼때도 HTTP프로토콜을 이용하나 메일서버와 메일서버간의 데이터 교환은 여전히 SMTP를 이용한다.

<br><br>

## DNS

---

기억하기 힘든 ip주소를 기억하기 쉬운 이름으로 맵핑시켜주는 서비스이다.

엄밀히 말하면 한쪽뿐만이 아닌 도메인 이름을 ip로 바꿔주거나 ip를 도메인 이름으로 바꿔주는 서비스

<br>

### ✔ 특징

- 전송계층의 `TCP`와 `UDP`를 모두 사용한다.
  기본적으로는 `UDP`를 사용하며, 네임서버끼리의 데이터 백업 / 이동과 같이 중요한 전송을 할때는 `TCP`를 이용한다.
- `질의` : 네임서버에게 ip주소의 도메인을 물어보는 것
- `응답` : 질의에 대한 대답
- `TTL` : 캐시 정보 (도메인 정보) 유지 시간

<br>

### ✔ ip주소 변한 외의 추가 서비스

- **호스트 엘리어싱** : 복잡한 호스트 네임(`정식 호스트 네임`)을 가지고 있는 호스트는 하나 이상의 `별명`을 가질 수 있다.

- **메일 서버 엘리어싱** : 전자 메일 주소를 기억하기 쉽게 간단한 별칭을 가질 수 있다.

  기업의 메일 서버와 웹 서버가 같은 호스트 네임을 갖는 것을 허용.

- **부하 분산** : 중복 웹 서버와 같은 중복 서버 사이에 부하를 분산하기 위해 DNS사용.
  여러개의 ip를 갖는 서버들이 한개의 도메인을 갖게 하여 부하를 분산 시킨다.

<br>

### ✔ DNS 동작 원리

- 단일 네임 서버 : 하나의 네임서버가 직접 클라이언트와 상호작용하며 응답을 하는 방식.

  수많은 호스트를 가진 오늘날의 인터넷에 이 방식은 `서버의 고장` , `트래픽 양`이 과도할 때, 물리적으로 `먼 거리`의 서버, `유지관리`과 같은 문제점들로 확장성이 부족하여 적합하지 않다.

- 분산 계층 데이터 베이스 : 네임 서버사이에 계층을 나누어 네임서버 끼리 상호작용하여 서비스하는 방식

  - 루트 DNS : 제일 최상단의 DNS서버로 책임 DNS서버와 연결되어 있다.

  - 최상위 레벨 도메인 (TLD) 서버 : com,org,net,edu와 같은 상위 레벨 도메인이나 kr,uk,us와 같은 국가 레벨의 도메인에 대한 서버
  - 책임 DNS 서버 : 인터넷에 접근하기 쉬운 호스트를 가진 모든 기관들이 갖고 있는 서버로 제일 하위 레벨
  - 로컬 DNS 서버 : 계층구조에 속하지 않는 서버로 `ISP`들은 로컬 DNS서버를 갖고 있어 위의 서버들과 상호작용(질의,응답)을 수행.

### ✔ 동작 방법

- 반복적 질의 : 로컬 DNS가 루트 DNS부터 아래로 차례대로 질의를 하여 도메인을 응답받는 방식

  로컬DNS가 바쁘다.

- 재귀적 질의 : 로컬 DNS는 루트 DNS에게 루트는 TLD에게 TLD는 책임에게 재귀적으로 질의를 하며 응답또한 재귀적으로 하는 방식

  루트 DNS가 바쁘다.

### ✔ DNS 캐싱

질의 수 (메세지 수)를 줄여 트래픽 부하를 줄이기 위해 사용하는 방법으로 응답에 대한 정보를 갖고있다가 동일한 요청시 바로 처리하는 방법

<br><br>

## CDN (콘텐츠 분배 네트워크)

---

스트리밍 비디오 서비스 제공을 위해 나온 네트워크

<br>

### ✔ 초기의 스트리밍 서비스

**스트리밍 HTTP 이용** : 조건이 허용되는 대로 HTTP 응답을 전송 하고 호스트(수신자)는 동영상이 시작할 수 있는 `시작 임계값`을 초과하면 재생 시작하는 방식으로 서비스.

**문제점** : 많은 클라이언트들은 다양한 위치애 위치해있어 가용 대역폭의 차이가 나는데 불구하고 같은 파일을 전송해 딜레이가 발생하게 된다.

<br>

### ✔ DASH 적용 (Dynamic Adaptive Streaming Http)

여러버전의 비디오를 인코딩 하여 대역폭마다 다른 비트율의 파일을 전송하는 방식.

스마트폰과 같이 이동 네트워크를 사용하는 종단간 가용 대역폭도 적용.

<br>

### ✔ CDN 등장

지역적으로 분산된 여러 서버에 동영상을 복사하여 저장하고 제공하는 방법

`pull`방식

<br>

**철학**

- `Enter Deep` : 서버 클러스터를 곳곳에 많이 구축하여 `접속 ISP` 네트워크에 접속하여 가까이서 동영상 서비스 제공하는 방법.

- `Bring Home` : 적은 수의 핵심 지역에 큰 규모의 서버를 구축하여 접속ISP대신 `지역 IXP`에 접속해서 호스트들을 가까이에 있는 것처럼 만들어 제공하는 방법.

  `Enter Deep`에 비해 유지 및 관리 비용이 줄어드는 대신 사용자가 느끼는 지연시간과 처리율은 상대적으로 나빠진다.

<br>

**클러스터 선택 정책**

- `지리적으로 가장 가까운` : 간단한 방법이고 대부분의 클라이언트를 대상으로 잘 동작하나 지리적으로 가장 가까운 클러스터가 `홉`_(네트워크 경로의 길이)_ 의 수가 가장 적은 클러스터가 아닐 수 있다.

- `실시간 측정` : 클러스터와 클라이어느 간의 지연 및 손실 성능을 주기적으로 측정

<br><br>

책의 마지막 부분에 python 을 이용한 소켓 프로그래밍 방법이 기재 되어 있어, 리눅스기반의 c로 구현 해본 간단한 멀티스레드 소켓 프로그램 링크를 남겨본다.

[(바라카 게임) 소켓 프로그램](https://github.com/gowoonsori/KPU/tree/master/bakaraGame)
