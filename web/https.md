# HTTPS

Http 프로토콜을 통한 데이터 송수신은 패킷을 통해 payload를 통해 내용을 훔쳐볼 수 있는 보안적의 문제가 존재하여, 만든 Http의 Secure를 붙인 HTTPS프로토콜 (Http + SSL/TLS)

암호화 통신 채널을 설정후에 데이터를 전송하는 방법으로 일종의 전송 계층 위에 하나의 추가적인 계층에서 데이터를 암호화하고 복호화 하여 주고 받는 방식 (전송계층 보안 프로토콜)

## 특징

- `Ciper suite` : `대칭키 암호`, `공개키 암호`, `일방향 해시함수`, `메세지 인증코드`, `의사난수 생성기`, `전자서명`등의 사용되는 알고리즘들의 문제가 발견시 교환하여 사용가능 하다.

- 기밀성 : DES, RC4와 같은 `대칭키 암호화 알고리즘`을 사용하여 기밀성 제공 ( 비밀키는 handshake 과정 중 생성)

- 상호 인증 : 인증에는 RSA(`비대칭키 암호 알고리즘`), DSS(`전자서명 알고리즘`), X.509(`공개키 알고리즘`) 이 사용

- 메시지 무결성 : `해시 알고리즘`을 사용해 메시지 인증코드를 만들어 메시지에 포함시켜 신뢰성 있는 통신 가능

## 동작 과정

웹서버의 정보 등록 과정

1. 웹 서버는 자신의 `정보`와 `공개키`를 `인증기관(CA)`에 제출
1. 인증기관은 검증을 거친 후 이 정보를 `개인키`로 암호화 -> `사이트 인증서`
1. 웹 브라우저는 인증기관의 `공개키`를, 서버는 `인증서`를 갖는다.

클라이언트의 연결 과정 (SSL hanshake)

1. 3-Way HandShaking
2. 클라리언트는 서버에게 사용가능한 `SSL버전`,`세션 식별자`,`암호 방식(Ciper Suit)`, `압축방법`과 `랜덤 데이터`를 서버에게 알린다. (Client Hello)
3. 서버는 클라이언트에게 사용가능 `SSL버전`,`세션 식별자`,`선택한 암호 방식(select Ciper Suit)`, `압축방법`과 `랜덤 데이터`를 응답 (Server Hello)
   1. `인증서`를 같이 클라이언트에게 발송 (Certificate Message)
   1. `인증서`가 없거나 서명용으로만 사용한다면 `Server key Exchange` 메시지 전송
   1. 클라이언트가 신뢰 할 수 있는지 확인하기 위해 클라이언트의 인증서를 요구하기도 하는데 생략 가능하다.
4. 서버의 전송이 끝나면 Server Hello Done 메시지 전달
5. 클라이언트는 받은 `인증서`를 신뢰기관으로 부터 유효한 인증서인지 확인후 `세션키`로 사용할 48byte의 `Pre-Master Key(대칭 키로 활용)`를 `랜덤 데이터1,2`를 조합해 랜덤으로 생성하고 `공개키`로 `암호화`해서 서버에게 전송 (Client key Exchange)
6. 서버는 `개인키`로 클라이언트로부터 받은 `Pre-Master Key`를 복호화
7. 이런 방식으로 서버와 클라이언트는 `Pre-Master Key` ->`master secret` -> `session key(대칭 키)` 생성
   Session
8. `session key(대칭 키)`를 활용해 대칭키 암호화 방식 통신
   end session
9. 세션종료 후 `session key(대칭 키)` 폐기

## SSL

Secure Sockets Layer의 약자로 Netscape사에서 개발 하였다.

과거의 프로토콜로 v1.0, v2.0는 보안 취약점 이슈가 있어 3.0버전으로 개선이 되었으며, v3.0은 TLS 1.0의 기초과 되었다.

## TLS

Transport Layer Security의 약자로 IETF가 개발 하였다.

2015년에 IETF에 의해 SSL3.0 사용 중지가 되어 SSL과 비슷하지만 상호 호환이 되지 않는 프로토콜

- v1.0 : SSL 3.0의 취약점이 거의 해결되었고 SHA1알고리즘이 주로 사용 되고 SHA256도 지원되나 XP,vista에서 마지막으로 지원되었다.
- v1.1 : 2006년에 공개되어 블록 체인공격의 방어와 IANA등록 파라미터 지원이 추가되었다. (대부분의 브라우저 vendor들은 지원 중단)
- v1.2 : 2008년 8월에 배포 되어 취약한 SHA1알고리즘을 버리고 SHA256만 사용한다
- v1.3 : 2018년에 처음 게시가 되어 handshaking 시에 RTT을 2->1로 줄이고 0-RTT기능으로 연결 속도를 향상 시켰다.

  확장 기능으로 SNI필드에 대한 암호화 규격인 ESNI 초안을 제시하였으나 표준에는 포함 x

  RC4, RSA, SHA-1, CBC Mode Ciphers, MD5, Various Diffie-Hellman groups, DES, 3DES, EXPRT-strength ciphers 알고리즘 지원 중단

  > SNI
  >
  > HandShaking과정 중에 클라이언트가 어느 도메인에 접속 하려는지 서버에 알리는 역할의 기술로 하나의 웹 서버 도메인(같은 IP주소와 TCP포트 번호)에 여러개의 인증 서를 사용하려고 할 때, 어떤 인증서를 사용할지 모르는 인증의 문제가 발생하는 데 이를 해결하기 위한 방법
  >
  > 하나의 인증서의 모든 호스트명을 집어넣게 되면 어렵거나 불가능한 일이기 때문에 SNI라는 가상 도메인의 호스트명을 서버로 전송하여 그에 맞는 인증서를 전달하는 기술
  >
  > SSL 인증서 DNS name정보를 웹서버 도메인 헤더정보와 매칭 해주는 기술
  >
  > 표준이 아니라 확장 기능이기 때문에 SNI의 암호 방식이 없고 평문으로 전송 -> ESNI기술 등장

  > ESNI
  >
  > 평문으로 전달된다는 SNI의 특성때문에 감청을 방지 하기위해 나온 기술로 서버의 공개키가 클라이언트에게 전달되는 시점을 DNS통신 단계로 앞당겨 서버와 연결하는 시점에 해당 공개키로 도메인(SNI)를 암호화하는 방식
  >
  > DoH(DNS over HTTPS)가 활성화 되지 않는다면 DNS통신 암호화가 이루어지 않아 현재는 firefox에서만 지원이 된다.

## 한국의 https 차단과 관련해서

현재 한국의 Https 차단 방식은 SNI가 평문으로 전송된다는 점을 이용하여 사용자의 https연결중 차단 SNI라면 서버가 클라이언트에게 응답하는 것보다 빨리 응답(error page)를 보내 차단 하는 방식

해결 방법

- DoH / ESNI : CloudFlaure Dns (1.1.1.1)이 ESNI를 지원하는 점을 이용하여 휴대폰은 어플을 통해 우회가 가능하고, PC는 이를 모두 지원하는 것은 아직 firefox뿐이다.

  단점 : 접속하는 ip주소는 그대로 노출이 되고 트래커의 아무런 방어성능이 없다.

- VPN : Virtural Private Network 의 약자로 개인정보보호와 익명성 유지를 위해 데이터를 암호화하고 라우팅해야하기 때문에 물리적으로 먼 지역의 라우터부터 요청을 시작하기 때문에 속도가 느려질 수 있다.

- MTU 쪼개기 : Maximum Transmission Unit의 약자로 한번에 보낼 수 있는 패킷의 최대 단위인데 기본 1500byte로 설정이 되어있는데 잘게 쪼개어 보내는 방법으로 데이터를 쪼개 접속하려는 도메인을 알지 못하게 하는 방법
